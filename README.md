# PuzzlePlatform

------

## Types of Multiplayer game

- 언리얼은 Real-time session-based 게임에 적합하게 설계되어 있다.

### Session-Based Stages

- 세션 기반 게임은 세 단계를 거침
  1. Discovery
     - 온라인에 있는 다른 사람을 찾고, 게임을 호스팅하고, 함께 참여할 수 있는 세션을 찾음.
  2. Connection
     - 세션에 참여하여 클라이언트가 서버에 조인하게 됨
  3. Synchronistion
     - 우리가 보고 있는 것이 플레이어와 동일한 것인지 확인해야 함
     - 별도의 네트워크 연결을 통해 실행되는 경우에도 마찬가지임
     - 같은 컴퓨터에서 실행되지 않더라도 게임을 매끄럽게 만드는 방법과 그 동기화를 유지
- PuzzlePlatform에서는 2번 Connection에 대해 중점적으로 다룰 것

### Input and State

- 가장 중요한 두가지는 입력(input)과 상태(state)임.
- 상태(state)
  - 기본적으로 월드의 모든 것, 위치, 속도, 플레이어들이 보는 모든 것에 영향을 줄 수 있는 것을 의미
  - 상태는 엔진에 의해 화면에 표시되는 이미지로 렌더링되는 것
  - 액터의 모든 변형, 컴포넌트의 다양한 변수, 혹은 폭발이 일어났는지의 여부, 액터가 특정 속도로 특정 위치에 있는지의 여부 등 
- 입력(input)
  - 우리는 상태에 몇가지 동작을 추가함
    - 버튼을 누르거나 조이스틱을 움직이거나
  - 언리얼 Tick에서는 현재 상태를 현재 입력 또는 현재 작업과 결합하고 두번째 상태인 다음 상태와 결과를 결합함
  - 그런 다음 이 상태는 렌더링되어 플레이어에게 표시될 것임
  - 이 싸이클은 반복됨
- 분명히 좋은 멀티플레이어 게임이 되기 위해선 다른 플레이어가 게임의 상태에 동의해야 함.

### Peer-to-Peer

- 플레이어 모두 서로 소통하는 상태임
- 한명의 플레이어가 입력을 하면 다른 모든 플레이어가 그 입력에 따라 상태를 업데이트함
- 내 상태를 올바르게 업데이트하기 위해서는 상태를 업데이트하고 다음 프레임으로 이동하기 전에 즉, 다음 틱으로 넘어가기전에 다른 모든 사람의 입력을 받기 위해 기다려야 한다는 것.
  - 워3로 예를 들어보면 내가 블마를 잡기 위해 데스코일을 날렸다고 했을때, 상대방은 흡수하기 위해 무적을 사용했다고 가정해보자. 다음 상태가 모두가 동의할 수 있는 상태가 되려면 다음 프레임으로 넘어가기전에 오크 플레이어의 입력을 기다려야 함. 만약 오크의 입력을 기다리지 않고 상태를 업데이트하면 내 화면에서는 블마가 죽고, 오크의 화면에선 블마가 무적을 사용해서 살았을 것임. 이것은 올바르지 못함.
- 이것은 매우 크리티컬한 문제임. 왜냐하면 ping이 가장 느린 사람을 기다려야 한다는 것을 의미하기 때문
- 이것은 엄청나게 느린 게임으로 이어질 수 있음
- 이것은 P2P 아키텍쳐의 치명적인 단점
- 또 다른 단점은 보안임. 치팅같은 문제.

### Client-Server Model

- 클라이언트는 다른 클라이언트들에게 이야기할 정보가 있을 때 그것을 서버로 보냄
- 해당 서버는 상태를 업데이트하고 그 상태는 신뢰할 수 있게 됨
- 그 후 서버는 다른 모든 클라이언트에게 자기 자신의 상태의 복사본을 업데이트함
- 언리얼이 사용하는 모델

